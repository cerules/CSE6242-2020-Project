<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="lib/d3.v5.min.js"></script>
<script type="text/javascript" src="lib/d3-scale-chromatic.v1.min.js"></script>
<style>
    body {
        background-color: white;
        font: 16px Arial;
    }

    div#halfpage {
        height: 699px;
        width: 1199px;
        border: 2px solid #000;
        overflow-y: auto;
    }

    path.link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
    }

    circle {
        stroke: #fff;
        stroke: black;
        stroke-width: 1.5px;
    }

    text {
        fill: #000;
        font: 10px sans-serif;
        pointer-events: none;
    }


    * {
        box-sizing: border-box;
    }

    .autocomplete {
        /*the container must be positioned relative:*/
        position: relative;
        display: inline-block;
    }

    input {
        border: 1px solid transparent;
        background-color: #f1f1f1;
        padding: 10px;
        font-size: 16px;
    }

    input[type=text] {
        background-color: #f1f1f1;
        width: 100%;
    }

    input[type=submit] {
        background-color: DodgerBlue;
        color: #fff;
    }

    .autocomplete-items {
        position: absolute;
        border: 1px solid #d4d4d4;
        border-bottom: none;
        border-top: none;
        z-index: 99;
        /*position the autocomplete items to be the same width as the container:*/
        top: 100%;
        left: 0;
        right: 0;
    }

    .autocomplete-items div {
        padding: 10px;
        cursor: pointer;
        background-color: #fff;
        border-bottom: 1px solid #d4d4d4;
    }

    .autocomplete-items div:hover {
        /*when hovering an item:*/
        background-color: #e9e9e9;
    }

    .autocomplete-active {
        /*when navigating through the items using the arrow keys:*/
        background-color: DodgerBlue !important;
        color: #ffffff;
    }
</style>

<body>
    <script>

        function autocomplete(inp, arr) {
            /*the autocomplete function takes two arguments,
            the text field element and an array of possible autocompleted values:*/
            var currentFocus;
            /*execute a function when someone writes in the text field:*/
            inp.addEventListener("input", function (e) {
                var a, b, i, val = this.value;
                /*close any already open lists of autocompleted values*/
                closeAllLists();
                if (!val) { return false; }
                currentFocus = -1;
                /*create a DIV element that will contain the items (values):*/
                a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                /*append the DIV element as a child of the autocomplete container:*/
                this.parentNode.appendChild(a);
                /*for each item in the array...*/
                for (i = 0; i < arr.length; i++) {
                    /*check if the item starts with the same letters as the text field value:*/
                    if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
                        /*create a DIV element for each matching element:*/
                        b = document.createElement("DIV");
                        /*make the matching letters bold:*/
                        b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
                        b.innerHTML += arr[i].substr(val.length);
                        /*insert a input field that will hold the current array item's value:*/
                        b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
                        /*execute a function when someone clicks on the item value (DIV element):*/
                        b.addEventListener("click", function (e) {
                            /*insert the value for the autocomplete text field:*/
                            inp.value = this.getElementsByTagName("input")[0].value;
                            /*close the list of autocompleted values,
                            (or any other open lists of autocompleted values:*/
                            closeAllLists();
                        });
                        a.appendChild(b);
                    }
                }
            });
            /*execute a function presses a key on the keyboard:*/
            inp.addEventListener("keydown", function (e) {
                var x = document.getElementById(this.id + "autocomplete-list");
                if (x) x = x.getElementsByTagName("div");
                if (e.keyCode == 40) {
                    /*If the arrow DOWN key is pressed,
                    increase the currentFocus variable:*/
                    currentFocus++;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 38) { //up
                    /*If the arrow UP key is pressed,
                    decrease the currentFocus variable:*/
                    currentFocus--;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 13) {
                    /*If the ENTER key is pressed, prevent the form from being submitted,*/
                    e.preventDefault();
                    if (currentFocus > -1) {
                        /*and simulate a click on the "active" item:*/
                        if (x) x[currentFocus].click();
                    }
                }
            });
            function addActive(x) {
                /*a function to classify an item as "active":*/
                if (!x) return false;
                /*start by removing the "active" class on all items:*/
                removeActive(x);
                if (currentFocus >= x.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (x.length - 1);
                /*add class "autocomplete-active":*/
                x[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(x) {
                /*a function to remove the "active" class from all autocomplete items:*/
                for (var i = 0; i < x.length; i++) {
                    x[i].classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                /*close all autocomplete lists in the document,
                except the one passed as an argument:*/
                var x = document.getElementsByClassName("autocomplete-items");
                for (var i = 0; i < x.length; i++) {
                    if (elmnt != x[i] && elmnt != inp) {
                        x[i].parentNode.removeChild(x[i]);
                    }
                }
            }
            /*execute a function when someone clicks in the document:*/
            document.addEventListener("click", function (e) {
                closeAllLists(e.target);
            });
        }        

        var idNodeMap = {};
        var links = [];
        var nodes = {};
        Promise.all([
            d3.csv("words2.csv"),
            d3.csv("edges2.csv")
        ]).then(function (files) {
            let data = files[0];
            data.forEach(function (d) {
                if (d.word) {
                    var temp = d.word.split("|");
                    idNodeMap[d.id] = temp[0];
                }
            });

            data = files[1];
            data.forEach(function (d) {
                var skipFlag = 1;
                for (i = 0; i < links.length; i++) {
                    link = links[i];
                    if (link.source == idNodeMap[d.target] && link.target == idNodeMap[d.source]) {
                        skipFlag = 0;
                        break;
                    }
                }
                if (skipFlag) {
                    var tempdata = { source: idNodeMap[d.source], target: idNodeMap[d.target] };
                    links.push(tempdata);
                }
            });
        }).then(function (data) {
            links.forEach(function (link) {
                link.source = nodes[link.source] ||
                    (nodes[link.source] = { name: link.source });
                link.target = nodes[link.target] ||
                    (nodes[link.target] = { name: link.target });
            });

            var width = 1200,
                height = 700,
                active = d3.select(null);

            var toggle = 0;

            // Make object of all neighboring nodes.
            var linkedByIndex = {};
            links.forEach(function (d) {
                linkedByIndex[d.source + ',' + d.target] = 1;
                linkedByIndex[d.target + ',' + d.source] = 1;
            });

            // A function to test if two nodes are neighboring.
            function neighboring(a, b) {
                return linkedByIndex[a.index + ',' + b.index];
            }
            var autocompForm = d3.select("body").append("form").attr("autocomplete", "off");
            var autocompDiv = autocompForm.append("div")
                .attr("class", "autocomplete")
                .attr("style", "width:300px;");

            var autocompEntry = autocompDiv.append("input")
                .attr("id", "myInput")
                .attr("type", "text")
                .attr("name", "Words")
                .attr("placeholder", "Words");

            console.log(Object.keys(nodes));
            autocomplete(document.getElementById("myInput"), Object.keys(nodes));

            // var search = d3.select("body").append('form').attr('onsubmit', 'return false;');

            // var box = search.append('input')
            //     .attr('type', 'text')
            //     .attr('id', 'searchTerm')
            //     .attr('placeholder', 'Type to search...');

            var button = autocompForm.append('input')
                .attr('type', 'button')
                .attr('value', 'Search')
                .on('click', function () { searchNodes(); });
            function searchNodes() {
                // var term = document.getElementById('searchTerm').value;
                var term = document.getElementById('myInput').value;
                var selected = svg.selectAll('.node').filter(function (d, i) {
                    return d.name.toLowerCase().search(term.toLowerCase()) == -1;
                });
                var path = svg.selectAll('path');
                svg.call(zoom.transform, d3.zoomIdentity.translate(100, 50).scale(0.8));
                console.log(selected);
                selected.style('opacity', '0');
                path.style('stroke-opacity', '0');
                d3.selectAll('.node').transition().duration(5000).style('opacity', '1');
                d3.selectAll('path').transition().duration(5000).style('stroke-opacity', '0.6');
            }

            var force = d3.forceSimulation()
                .nodes(d3.values(nodes))
                .force("link", d3.forceLink(links).distance(100))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX())
                .force("y", d3.forceY())
                .force("charge", d3.forceManyBody().strength(-250))
                .alphaTarget(1)
                .on("tick", tick)

            var v = d3.scaleLinear()
                .range([0, 100]);

            v.domain([0, d3.max(links, function (d) { return d.value; })]);

            var container = d3.select("body").append("div")
                .attr("id", "halfpage");

            var zoom = d3.zoom().scaleExtent([0.25, 8]).on("zoom", zoomed);
            function clicked(d) {
                if (active.node() === this) return reset();
                active.classed("active", false);
                active = d3.select(this).classed("active", true);

                var bounds = node.bounds(d),
                    dx = bounds[1][0] - bounds[0][0],
                    dy = bounds[1][1] - bounds[0][1],
                    x = (bounds[0][0] + bounds[1][0]) / 2,
                    y = (bounds[0][1] + bounds[1][1]) / 2
                scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
                    translate = [width / 2 - scale * x, height / 2 - scale * y];
                console.log(x, y, dx, dy);

                svg.transition()
                    .duration(750).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)); // updated for d3 v4
            }
            function reset() {
                active.classed("active", false);
                active = d3.select(null);

                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
            }

            function zoomed() {
                d3.event.transform.x = 0;
                d3.event.transform.y = 0;

                svg.style("stroke-width", 1.5 / d3.event.transform.k + "px");
                svg.attr("transform", d3.event.transform);
            }

            // If the drag behavior prevents the default click,
            // also stop propagation so we don’t click-to-zoom.
            function stopped() {
                if (d3.event.defaultPrevented) d3.event.stopPropagation();
            }

            var svg = container.append("svg")
                .attr("width", width + "px")
                .attr("height", height + "px")
                .attr("display", "block")
                .attr("margin", "auto")
                .attr("overflow", "visible")
                .attr("background-position", "left top")
                .on("click", stopped, true);
            // .call(d3.zoom().on("zoom", function () {
            //     svg.attr("transform", d3.event.transform)
            // }));
            svg.call(zoom);
            svg.call(zoom.transform, d3.zoomIdentity.translate(100, 50).scale(0.4));

            svg.append("svg:defs").selectAll("marker")
                .data(["end"])
                .enter().append("svg:marker")
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 15)
                .attr("refY", -1.5)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5")
                .on("click", reset);

            // add the links and the arrows
            var path = svg.append("g")
                .selectAll("path")
                .data(links)
                .enter()
                .append("path")
                .attr("class", function (d) { return "link " + d.type; })
                .style("stroke", "black");

            // define the nodes
            var node = svg.selectAll(".node")
                .data(force.nodes())
                .enter().append("g")
                .attr("class", "node")
                .on("dblclick", dblclick)
                .on("click", clicked)
                .on('click', function (d, i) {
                    if (toggle == 0) {
                        // Ternary operator restyles links and nodes if they are adjacent.
                        d3.selectAll('path').style('stroke-opacity', function (l) {
                            return l.target == d || l.source == d ? 1 : 0.1;
                        });
                        d3.selectAll('.node').style('opacity', function (n) {
                            return neighboring(d, n) ? 1 : 0.1;
                        });
                        d3.select(this).style('opacity', 1);
                        toggle = 1;
                    }
                    else {
                        // Restore nodes and links to normal opacity.
                        d3.selectAll('path').style('stroke-opacity', '0.6');
                        d3.selectAll('.node').style('opacity', '1');
                        toggle = 0;
                    }
                })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            function myNodeWeight(d) {
                d.weight = links.filter(function (l) {
                    return l.source.index == d.index || l.target.index == d.index
                }).length;

                return 5 + d.weight;
            }

            var myColor = d3.scaleSequential()
                .domain([1, 9])
                .interpolator(d3.interpolateWarm);


            function dblclick(d) {
                if (d.fixed == true) {
                    d3.select(this).select("circle")
                        .style("fill", function (d) { return myColor(myNodeWeight(d)) });
                    d.fixed = false
                } else {
                    d3.select(this).select("circle")
                        .style("fill", "red");
                    d.fixed = true;
                }
            };

            // add the nodes
            node.append("circle")
                .attr("r", function (d) {
                    return myNodeWeight(d)
                })
                .attr("fill", function (d) {
                    return myColor(myNodeWeight(d));
                });



            node.append("text")
                .attr("x", 13)
                .attr("y", 2)
                .text(function (d) { return d.name; })
                .style("font-weight", "800");

            svg.append("text")
                .attr("x", width - 250)
                .attr("y", 50)
                .text("psn6")
                .style("font-size", "14px");

            // add the curvy lines
            function tick() {
                path.attr("d", function (d) {
                    var dx = d.target.x - d.source.x,
                        dy = d.target.y - d.source.y,
                        dr = Math.sqrt(dx * dx + dy * dy);
                    return "M" +
                        d.source.x + "," +
                        d.source.y + "A" +
                        dr + "," + dr + " 0 0,1 " +
                        d.target.x + "," +
                        d.target.y;
                });

                node
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    })
            };

            function dragstarted(d) {
                if (!d3.event.active) force.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            };

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            };

            function dragended(d) {
                if (!d3.event.active) force.alphaTarget(0);
                if (d.fixed == true) {
                    d.fx = d.x;
                    d.fy = d.y;
                }
                else {
                    d.fx = null;
                    d.fy = null;
                }
            };


        });


    </script>
</body>

</html>